{% extends "web/base.html" %}

{% block content %}
	<div class="row">
		<div class="col-md-9">
			<div id="map" class="img-thumbnail"></div>
		</div>
	
		<div class="col-md-3">
			<div id="modelDetails" class="text panel panel-default">
				<h2 id="modelName">
					Autism support groups
				</h2>	
				
				<p id="modelDescription">
					This is a map of population density overlayed with markers marking where autism support groups are located within Victoria.
				</p>
			</div>
		</div>
	</div>
{% endblock %}

{% block javascript %}

    <script type="text/javascript">

        var map = null;
        var highlightHighest = false;
        var layerToggles = null;

        var mapBounds = {{ map_bounds|safe }};

        /**
         * Create map, setup basemap layer, and return it.
         * @return L.Map
         */
        var initMap = function() {

            map = L.map('map', {
                maxBounds : mapBounds
            }).setView([ -42.742572964499999, 147.258816064 ], {{ default_zoom }});

            var dummyLayer = L.polygon([], {});
            var toggles = { 'Highest value' : dummyLayer };
            var options = { collapsed : false };
            layerToggles = L.control.layers( {}, toggles, options ).addTo( map );
            map.on( 'overlayadd', function( event ) {
                if ( dummyLayer == event.layer ) {
                    highlightHighest = true;
                    restyleIndexLayer();
                }
            }).on( 'overlayremove', function( event ) {
                if ( dummyLayer == event.layer ) {
                    highlightHighest = false;
                    restyleIndexLayer();
                }
            });

        };


        var getColourScale = function() {
            var colours = {
                green: ['#ffffcc', '#c2e699', '#78c679', '#31a354', '#006837'],
                red: ['#ffeeee', '#ffeeee', '#fee0d2', '#fc9272', '#de2d26']
            };

            return colours.red;
        };


        var style = function( feature ) {

            var lgaCode = feature.properties.lga_code;
            var hasIndexModel = indexModelValues != null && indexModel != null;
            var indexValue = hasIndexModel && indexModelValues.hasOwnProperty( lgaCode ) ? indexModelValues[ lgaCode ] : null;
            var isHighest = highlightHighest && highestIndexModelValues.hasOwnProperty( lgaCode );

            var getColor = function(properties) {

                if ( !hasIndexModel ) {
                    // Haven't loaded the values for colourising yet. Set to white, and wait until
                    // we get back here after loading the model results (at which point we will be
                    // able to actually colourise the values).
                    return '#ffffff';
                } else if ( indexValue == null ) {
                    // Hrmm, that is odd. Why do we have an LGA on the map, without a corresponding
                    // value in the index model?
                    return '#ff0000';
                }

                if ( isHighest ) {
                    return '#4444ff';
                }

                var colourList = getColourScale();
                if (indexValue < indexModel.quantile_1) {
                    return colourList[0];
                }
                else if (indexValue < indexModel.quantile_2) {
                    return colourList[1];
                }
                else if (indexValue < indexModel.quantile_3) {
                    return colourList[2];
                }
                else if (indexValue < indexModel.quantile_4) {
                    return colourList[3];
                }
                else {
                    return colourList[4];
                }
            };


            return {
                fillColor: getColor( feature.properties ),
                weight: 2,
                opacity: 1,
                color: "#ffffff",
                dashArray: '3',
                fillOpacity: 0.7
            };
        };


        var createLegend = function() {

            //Code for the legend in the bottom right of the corner
            var legend = L.control({position: 'bottomright'});

            legend.onAdd = function (map) {

                var div = L.DomUtil.create('div', 'info legend'),
                        grades = ['Lowest', 'Low', 'Medium', 'High', 'Highest'],
                        colour = getColourScale();

                // loop through our density intervals and generate a label with a colored square for each interval
                div.innerHTML += '<ul>';
                for (var i = 0; i < grades.length; i++) {
                    div.innerHTML +=
                            '<li><div class="legendBox" style="background:' + colour[i] + '"></div> ' + '<div class="legendText">' + grades[i] + '</div></li>';
                }
                div.innerHTML += '</ul>';

                return div;
            };

            return legend;
        };

		var loadDataQuery = function() {
            var host = 'overpass-api.de';
            var port = 80;
            var path = '/api/interpreter';
			var query = '?data=node[name=\"Gielgen\"];out;';
            var dataUrl = "http://" + host + ":" + port + path + query;

            $.ajax({
                type: "GET",
                url: dataUrl,
                dataType: 'xml',
                success: function(data){console.log('data')}
            });
        };

        var loadDjangoDataLayer = function( map, type, params, callback ) {
            var path = "/api/geo/" + type;
            $.ajax({
                type: "GET",
                url: path,
                dataType: 'json',
                data: params,
                success: callback
            });
        };

        // Keep track of the requests which are made. That way, if we are zooming in, and requesting
        // progressively more detailed geometry, we don't want to accidentally replace our nice fine
        // geometry with cruddy stuff from a previous (out of order) request.
        var indexLayerRequest = 0;
        var indexLayerResponse = 0;
        var indexLayerPreviousZoom = null;
        var indexLayerPreviousBounds = null;


        var loadIndexLayer = function( map, modelId ) {

            /**
             * When we send a request, we want to do two things:
             *  - Request a little extra space (so that when we pan, we don't immediately need
             *    to hit the server for more data
             *  - Round the numbers to something more whole, so that we have opportunities to
             *    cache responses and reuse in the future. For example, if you request bounds with
             *    a west value of 5.531 or 5.582, clamping both to the value of 5.5 means that
             *    they'd both require the same response, which is hopefully cached.
             */
            var boundsToRequest = function() {

                var padBounds = function(xpad, ypad, xround, yround) {

                    var bounds = map.getBounds();

                    var west = bounds.getWest() - xpad;
                    var east = bounds.getEast() + xpad;
                    var north = bounds.getNorth() + ypad;
                    var south = bounds.getSouth() - ypad;

                    west -= west % xround;
                    east -= east % xround + xround;
                    north -= north % yround + yround;
                    south -= south % yround;

                    return L.latLngBounds( [ south, west ], [ north, east ] )
                };

                var zoomLevel = map.getZoom();

                /*
                 * TODO: Could probably do with some tuning here.
                 * Specifically, the rounding should be increased, to make it more
                 * likely that two requests want the same geometry. Right now, panning
                 * around still results in quite a few uncached requests to the server
                 * which is fairly slow.
                 */
                if ( zoomLevel <= 4 ) {
                    return map.getBounds();
                } else if ( zoomLevel == 5 ) {
                    return padBounds( 10, 8, 5, 4 );
                } else if ( zoomLevel == 6 ) {
                    return padBounds( 3, 3, 1.5, 1.5 );
                } else if ( zoomLevel == 7 ) {
                    return padBounds( 3, 2, 1, 1 );
                } else if ( zoomLevel == 8 ) {
                    return padBounds( 2.5, 1.5, 1, 1 );
                } else {
                    return padBounds( 2.2, 1.2, 1, 1 );
                }
            };

            var calcSimplificationThreshold = function(zoomLevel) {
                if ( zoomLevel <= 4 ) {
                    return 0.22;
                } else if ( zoomLevel <= 5 ) {
                    return 0.08;
                } else if ( zoomLevel <= 6 ) {
                    return 0.06;
                } else if ( zoomLevel <= 8 ) {
                    return 0.025;
                } else if ( zoomLevel <= 9 ) {
                    return 0.01;
                } else if ( zoomLevel <= 10 ) {
                    return 0.007;
                } else if ( zoomLevel <= 11 ) {
                    return 0.005;
                } else {
                    return 0.001;
                }
            };

            var data = {
                simplification_threshold : calcSimplificationThreshold( map.getZoom() )
            };

            var requestedBounds = boundsToRequest();

            // Zoom level 4 includes the whole country, so don't bother restricting.
            if ( map.getZoom() > 4 ) {
                data.xmin  = requestedBounds.getWest();
                data.ymin  = requestedBounds.getSouth();
                data.xmax  = requestedBounds.getEast();
                data.ymax  = requestedBounds.getNorth();
            }

            if ( indexLayerPreviousZoom != null ) {
                if ( indexLayerPreviousZoom == map.getZoom() &&
                        indexLayerPreviousBounds.contains( map.getBounds() ) ) {
                    console.log( "Not requesting data, because we are within the previous request" );
                    return;
                }
            }

            var layerRequest = indexLayerRequest;
            indexLayerRequest ++;

            var oldZoom = map.getZoom();
            var oldBounds = requestedBounds;

            loadDjangoDataLayer( map, 'region', data, function (response) {

                // Discard incoming layers that are superseded by a newer request
                if ( layerRequest == indexLayerResponse ) {
                    if ( indexLayer != null ) {
                        console.log( "Removing previous index layer from map." );
                        map.removeLayer( indexLayer );
                    }

                    if ( regionLabelLayer == null ) {
                        regionLabelLayer = L.layerGroup();
                        regionLabelLayer.addTo( map );
                    } else {
                        regionLabelLayer.clearLayers();
                    }

                    var eachFeature = function( feature, layer ) {

                        var name = feature.properties.name;

                        if (feature.geometry.coordinates.length == 0 ) {
                            console.log( "Feature has no coordinates:" );
                            console.log( feature );
                            return layer;
                        }

                        var iconOptions = {
                            className : 'region-label'
                        };

                        var markerOptions = {
                            icon: new L.DivIcon( iconOptions )
                        };

                        var markerCenter = layer.getBounds().getCenter();

                        var marker = L.marker( markerCenter, markerOptions );

                        var labelOptions = {
                            noHide : true,
                            offset : [ -47.5, -15 ] // Average width of labels is about 95px wide for Victoria.
                        };

                        marker.bindLabel( name, labelOptions ).addTo( regionLabelLayer );
                        return layer;
                    };

                    console.log("Adding index layer to map.");
                    indexLayer = L.geoJson(response, {
                        style: style,
                        onEachFeature: eachFeature
                    }).addTo(map);

                    // Now that we've added the labels to the map, they should all have dom elements
                    // that we can interrogate regarding size and position. We'll take the opportunity
                    // to find overlapping ones, and hide them.

                    var boundsOfKeptLabels = [];
                    $( '#map').find( '.leaflet-label' ).each( function( j, item ) {

                        var bounds = item.getBoundingClientRect();
                        length += bounds.width;
                        var overlap = false;

                        for ( var ii = 0; ii < boundsOfKeptLabels.length; ii ++ ) {

                            var i = boundsOfKeptLabels[ ii ];

                            var withinX =
                                    ( bounds.right > i.left && bounds.right < i.right ) ||
                                    ( bounds.left > i.left && bounds.left < i.right );
                            var withinY =
                                    ( bounds.bottom > i.top && bounds.bottom < i.bottom ) ||
                                    ( bounds.top > i.top && bounds.top < i.bottom );

                            if ( withinX && withinY ) {
                                overlap = true;
                                break;
                            }

                        }

                        if ( overlap ) {
                            console.log( "Overlap. Poo" );
                            $( this ).hide();
                        } else {
                            boundsOfKeptLabels.push( bounds );
                        }

                    });

                    // Store the cached versions from before the response was sent, because the user may
                    // have interacted with the map since then.
                    indexLayerPreviousZoom = oldZoom;
                    indexLayerPreviousBounds = oldBounds;

                }
                indexLayerResponse ++;

            });
        };

        var loadServiceLayer = function( map, modelId ) {

            var popupOptions = {
                className: "poi-info"
            };

            var initPopup = function( feature, layer ) {
                if ( feature.properties && feature.properties.name ) {
                    var html =
                        "<div class='name'>" + feature.properties.name + "</div>" +
                        "<p>" + feature.properties.description + "</p>";
                    layer.bindPopup( html, popupOptions );
                }
            };

            loadDjangoDataLayer( map, 'poi', {}, function (response) {

                var layer   = L.geoJson(
                    response,
                    {
                        style: style,
                        onEachFeature : initPopup
                    }
                ).addTo(map);

                layerToggles.addOverlay( layer, 'Support Groups' );

            });

        };

        var createOsmLayer = function() {

            var baseMapUrl = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
            var baseMapAttrib = 'Map data Â© <a href="http://openstreetmap.org">OpenStreetMap</a> contributors';
            return L.tileLayer(
                baseMapUrl,
                {
                    minZoom: {{ min_zoom }},
                    maxZoom: 14,
                    attribution: baseMapAttrib
                }
            );

        };

        var setupSearch = function( map ) {
            $( '#searchAndAddLayer' ).change( function() {

                var searchTerm = this.value;
                var osmLink = "http://nominatim.openstreetmap.org/search";
                var mapQuestLink = "http://open.mapquestapi.com/nominatim/v1/search";

                var mapBoundsString =
                    /* left */   mapBounds[ 0 ][ 1 ] + "," +
                    /* top  */   mapBounds[ 0 ][ 0 ] + "," +
                    /* right  */ mapBounds[ 1 ][ 1 ] + "," +
                    /* bottom */ mapBounds[ 1 ][ 0 ];

                $.getJSON(
                    mapQuestLink,
                    {
                        format : "json",
                        q : searchTerm,
                        viewbox : mapBoundsString,
                        bounded : 1,
                        limit : 10
                    },
                    function( response ) {

                        var geoJsonPoints = [];
                        for ( var i = 0; i < response.length; i ++ ) {
                            geoJsonPoints.push( response[ i ].geojson );
                        }

                        console.log( "Num results: " + response.length );
                        console.log( response );

                        L.geoJson( geoJsonPoints, {
                            style: style
                        }).addTo( map );

                    }
                )
            });
        };

        /*
         * Rather than passing the model values through with the geometry from the server,
         * we instead fetch them separately. This allows us to send through geometry
         * without anything that is specific to the model we are viewing. This in turn allows
         * heavy caching of the geometry, both server and client side.
         * The catch is, we need to remember to restyle the geometry each time we receive
         * some more from the server (by calling restyleIndexLayer()
         */
        var indexModelValues = null;
        var highestIndexModelValues = [];

        var restyleIndexLayer = function() {
            if ( indexLayer != null ) {
                indexLayer.setStyle( style );
            }
        };

        var initialiseModel = function() {

            loadIndexLayer( map, {{ index_model.id }} );

            {% if index_model.id == 1 %}
            loadServiceLayer( map, {{ index_model.id }} );
            {% endif %}

            indexModel = {{ index_model.to_json|safe }};
            indexModelValues = {{ json_index_model_data|safe }};

            var toHighlight = 5;
            highestIndexModelValues = {};

            // Find the highest LGA's in the model, for highlighting purposes
            for ( var key in indexModelValues ) {
                var value = indexModelValues[ key ];
                if ( Object.keys( highestIndexModelValues ).length < toHighlight ) {
                    highestIndexModelValues[ key ] = value;
                } else {
                    // Iterate over each of the highest we have found so far and get
                    // the lowest of them.
                    var currentMinValue = Number.MAX_VALUE;
                    var currentMinKey = null;
                    for ( var k in highestIndexModelValues ) {
                        if ( highestIndexModelValues[ k ] < currentMinValue ) {
                            currentMinValue = highestIndexModelValues[ k ];
                            currentMinKey = k;
                        }
                    }

                    // Then we remove the lowest value, and replace it with the one
                    // we just found to be higher than it...
                    if ( currentMinValue < value ) {
                        delete highestIndexModelValues[ currentMinKey ];
                        highestIndexModelValues[ key ] = value;
                    }
                }
            }

            showModelDetails();
        };


        var showModelDetails = function() {

            if ( indexModel != null ) {
                restyleIndexLayer();
                $('#modelName').html( indexModel.name );
                $('#modelDescription').html( indexModel.description );
            }

        };


        var onZoomEnd = function() {
            /*console.log( 'Zoom level: ' + map.getZoom() );*/
            loadIndexLayer( map, 'region' );
        };


        var onPanEnd = function() {
            /*var bounds = map.getBounds();
            console.log( 'Panned map: [ [' + bounds.getSouth() + ', ' + bounds.getWest() + ' ], [' + bounds.getNorth() + ', ' + bounds.getEast() + '] ]' );
            console.log( map.getBounds() );*/
            loadIndexLayer( map, 'region' );
        };


        var indexLayer = null;
        var regionLabelLayer = null;

        initMap();
        map.on( 'zoomend', onZoomEnd );
        map.on( 'dragend',  onPanEnd  );
        createOsmLayer().addTo( map );
        createLegend().addTo( map );
        initialiseModel();

    </script>


{% endblock %}
