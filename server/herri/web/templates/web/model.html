{% extends "web/base.html" %}

{% block content %}
	<div class="row">
		<div class="col-md-9">
			<div id="map" class="img-thumbnail"></div>
		</div>
	
		<div class="col-md-3">
			<div id="modelDetails" class="text panel panel-default">
				<h2 id="modelName">
					Autism support groups
				</h2>	
				
				<p id="modelDescription">
					This is a map of population density overlayed with markers marking where autism support groups are located within Victoria.
				</p>
			</div>
		</div>
	</div>
{% endblock %}

{% block javascript %}

    <script type="text/javascript">

        var mapBounds = {{ map_bounds|safe }};

        /**
         * Create map, setup basemap layer, and return it.
         * @return L.Map
         */
        var initMap = function() {

            var map = L.map('map', {
                maxBounds : mapBounds
            }).setView([ -42.742572964499999, 147.258816064 ], {{ default_zoom }});

            return map;

        };

        var style = function( feature ) {

            var getColor = function(properties) {

                var lgaCode = properties.lga_code;

                if ( indexModelValues == null ) {
                    // Haven't loaded the values for colourising yet. Set to white, and wait until
                    // we get back here after loading the model results (at which point we will be
                    // able to actually colourise the values).
                    return '#ffffff';
                } else if ( !indexModelValues.hasOwnProperty( lgaCode ) ) {
                    // Hrmm, that is odd. Why do we have an LGA on the map, without a corresponding
                    // value in the index model?
                    return '#ff0000';
                }

                var value = indexModelValues[ lgaCode ];

                var colorlist = ['#ffffcc', '#c2e699', '#78c679', '#31a354', '#006837'];
                if (value < 1982) {
                    return colorlist[0];
                }
                else if (value < 6827) {
                    return colorlist[1];
                }
                else if (value < 19279) {
                    return colorlist[2];
                }
                else if (value < 57891) {
                    return colorlist[3];
                }
                else if (value < 1041839) {
                    return colorlist[4];
                }
            };

            return {
                fillColor: getColor( feature.properties ),
                weight: 2,
                opacity: 1,
                color: 'white',
                dashArray: '3',
                fillOpacity: 0.7
            };
        };

        var createLegend = function() {

            //Code for the legend in the bottom right of the corner
            var legend = L.control({position: 'bottomright'});

            legend.onAdd = function (map) {

                var div = L.DomUtil.create('div', 'info legend'),
                        grades = ['Lowest', 'Low', 'Medium', 'High', 'Highest'],
                        color = ['#ffffcc', '#c2e699', '#78c679', '#31a354', '#006837'];

                // loop through our density intervals and generate a label with a colored square for each interval
                div.innerHTML += '<ul>';
                for (var i = 0; i < grades.length; i++) {
                    div.innerHTML +=
                            '<li><div class="legendBox" style="background:' + color[i] + '"></div> ' + '<div class="legendText">' + grades[i] + '</div></li>';
                }
                div.innerHTML += '</ul>';

                return div;
            };

            return legend;
        };

		var loadDataQuery = function() {
            var host = 'overpass-api.de';
            var port = 80;
            var path = '/api/interpreter';
			var query = '?data=node[name=\"Gielgen\"];out;';
            var dataUrl = "http://" + host + ":" + port + path + query;

            $.ajax({
                type: "GET",
                url: dataUrl,
                dataType: 'xml',
                success: function(data){console.log('data')}
            });
        };

        var loadDjangoDataLayer = function( map, type, params, callback ) {
            var path = "/api/geo/" + type;
            $.ajax({
                type: "GET",
                url: path,
                dataType: 'json',
                data: params,
                success: callback
            });
        };

        // Keep track of the requests which are made. That way, if we are zooming in, and requesting
        // progressively more detailed geometry, we don't want to accidentally replace our nice fine
        // geometry with cruddy stuff from a previous (out of order) request.
        var indexLayerRequest = 0;
        var indexLayerResponse = 0;
        var indexLayerPreviousZoom = null;
        var indexLayerPreviousBounds = null;


        var loadIndexLayer = function( map, modelId ) {

            /**
             * When we send a request, we want to do two things:
             *  - Request a little extra space (so that when we pan, we don't immediately need
             *    to hit the server for more data
             *  - Round the numbers to something more whole, so that we have opportunities to
             *    cache responses and reuse in the future. For example, if you request bounds with
             *    a west value of 5.531 or 5.582, clamping both to the value of 5.5 means that
             *    they'd both require the same response, which is hopefully cached.
             */
            var boundsToRequest = function() {

                var padBounds = function(xpad, ypad, xround, yround) {

                    var bounds = map.getBounds();

                    var west = bounds.getWest() - xpad;
                    var east = bounds.getEast() + xpad;
                    var north = bounds.getNorth() + ypad;
                    var south = bounds.getSouth() - ypad;

                    west -= west % xround;
                    east -= east % xround + xround;
                    north -= north % yround + yround;
                    south -= south % yround;

                    return L.latLngBounds( [ south, west ], [ north, east ] )
                };

                var zoomLevel = map.getZoom();

                /*
                 * TODO: Could probably do with some tuning here.
                 * Specifically, the rounding should be increased, to make it more
                 * likely that two requests want the same geometry. Right now, panning
                 * around still results in quite a few uncached requests to the server
                 * which is fairly slow.
                 */
                if ( zoomLevel <= 4 ) {
                    return map.getBounds();
                } else if ( zoomLevel == 5 ) {
                    return padBounds( 10, 8, 5, 4 );
                } else if ( zoomLevel == 6 ) {
                    return padBounds( 3, 3, 1.5, 1.5 );
                } else if ( zoomLevel == 7 ) {
                    return padBounds( 3, 2, 1, 1 );
                } else if ( zoomLevel == 8 ) {
                    return padBounds( 2.5, 1.5, 1, 1 );
                } else {
                    return padBounds( 2.2, 1.2, 1, 1 );
                }
            };

            var calcSimplificationThreshold = function(zoomLevel) {
                if ( zoomLevel <= 4 ) {
                    return 0.22;
                } else if ( zoomLevel <= 5 ) {
                    return 0.08;
                } else if ( zoomLevel <= 6 ) {
                    return 0.06;
                } else if ( zoomLevel <= 8 ) {
                    return 0.025;
                } else if ( zoomLevel <= 9 ) {
                    return 0.01;
                } else if ( zoomLevel <= 10 ) {
                    return 0.007;
                } else if ( zoomLevel <= 11 ) {
                    return 0.005;
                } else {
                    return 0.001;
                }
            };

            var data = {
                simplification_threshold : calcSimplificationThreshold( map.getZoom() )
            };

            var requestedBounds = boundsToRequest();

            // Zoom level 4 includes the whole country, so don't bother restricting.
            if ( map.getZoom() > 4 ) {
                data.xmin  = requestedBounds.getWest();
                data.ymin  = requestedBounds.getSouth();
                data.xmax  = requestedBounds.getEast();
                data.ymax  = requestedBounds.getNorth();
            }

            if ( indexLayerPreviousZoom != null ) {
                if ( indexLayerPreviousZoom == map.getZoom() &&
                        indexLayerPreviousBounds.contains( map.getBounds() ) ) {
                    console.log( "Not requesting data, because we are within the previous request" );
                    return;
                }
            }

            var layerRequest = indexLayerRequest;
            indexLayerRequest ++;

            var oldZoom = map.getZoom();
            var oldBounds = requestedBounds;

            loadDjangoDataLayer( map, 'region', data, function (response) {

                // Discard incoming layers that are superseded by a newer request
                if ( layerRequest == indexLayerResponse ) {
                    if (indexLayer != null) {
                        console.log("Removing previous index layer from map.");
                        map.removeLayer(indexLayer);
                    }

                    console.log("Adding index layer to map.");
                    indexLayer = L.geoJson(response, {
                        style: style
                    }).addTo(map);

                    // Store the cached versions from before the response was sent, because the user may
                    // have interacted with the map since then.
                    indexLayerPreviousZoom = oldZoom;
                    indexLayerPreviousBounds = oldBounds;

                }
                indexLayerResponse ++;

            });
        };

        var loadServiceLayer = function( map, modelId ) {

            var callback = function (response) {

                L.geoJson(response, {
                    style: style
                }).addTo(map);

            };

            loadDjangoDataLayer( map, 'poi', {}, callback );
        };

        var createOsmLayer = function() {

            var baseMapUrl = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
            var baseMapAttrib = 'Map data © <a href="http://openstreetmap.org">OpenStreetMap</a> contributors';
            return L.tileLayer(
                baseMapUrl,
                {
                    minZoom: {{ min_zoom }},
                    maxZoom: 14,
                    attribution: baseMapAttrib
                }
            );

        };

        var setupSearch = function( map ) {
            $( '#searchAndAddLayer' ).change( function() {

                var searchTerm = this.value;
                var osmLink = "http://nominatim.openstreetmap.org/search";
                var mapQuestLink = "http://open.mapquestapi.com/nominatim/v1/search";

                var mapBoundsString =
                    /* left */   mapBounds[ 0 ][ 1 ] + "," +
                    /* top  */   mapBounds[ 0 ][ 0 ] + "," +
                    /* right  */ mapBounds[ 1 ][ 1 ] + "," +
                    /* bottom */ mapBounds[ 1 ][ 0 ];

                $.getJSON(
                    mapQuestLink,
                    {
                        format : "json",
                        q : searchTerm,
                        viewbox : mapBoundsString,
                        bounded : 1,
                        limit : 10
                    },
                    function( response ) {

                        var geoJsonPoints = [];
                        for ( var i = 0; i < response.length; i ++ ) {
                            geoJsonPoints.push( response[ i ].geojson );
                        }

                        console.log( "Num results: " + response.length );
                        console.log( response );

                        L.geoJson( geoJsonPoints, {
                            style: style
                        }).addTo( map );

                    }
                )
            });
        };

        /*
         * Rather than passing the model values through with the geometry from the server,
         * we instead fetch them separately. This allows us to send through geometry
         * without anything that is specific to the model we are viewing. This in turn allows
         * heavy caching of the geometry, both server and client side.
         * The catch is, we need to remember to restyle the geometry each time we receive
         * some more from the server (by calling restyleIndexLayer()
         */
        var indexModelValues = null;

        var restyleIndexLayer = function() {
            if ( indexLayer != null ) {
                indexLayer.setStyle( style );
            }
        };

        var loadModel = function( modelId ) {

            loadIndexLayer( map, modelId );
            if ( modelId == 1 ) { /* autism model... */
                loadServiceLayer( map, modelId );
            }

            $.getJSON( '/api/model/result/' + modelId + '/', function( data ) {
                indexModelValues = data;
                restyleIndexLayer();
            });

            $( '#modelName' ).html( '' );
            $( '#modelDescription' ).html( '' );

            $.getJSON( '/api/attribute_model/' + modelId + '/', function( data ) {
                var model = data.pop();
                $( '#modelName' ).html( model.fields.name );
                $( '#modelDescription' ).html( model.fields.description );
            });
        };


        var onZoomEnd = function() {
            /*console.log( 'Zoom level: ' + map.getZoom() );*/
            loadIndexLayer( map, 'region' );
        };


        var onPanEnd = function() {
            /*var bounds = map.getBounds();
            console.log( 'Panned map: [ [' + bounds.getSouth() + ', ' + bounds.getWest() + ' ], [' + bounds.getNorth() + ', ' + bounds.getEast() + '] ]' );
            console.log( map.getBounds() );*/
            loadIndexLayer( map, 'region' );
        };


        var indexLayer = null;
        var map = initMap();
        map.on( 'zoomend', onZoomEnd );
        map.on( 'dragend',  onPanEnd  );
        createOsmLayer().addTo( map );
        createLegend().addTo( map );

        loadModel( {{ model_id }} );

    </script>


{% endblock %}
